---
layout: post
title: "进港排序研究"
date: 2019-06-17
description: "排序算法梳理"
tag: 民航研究

---

## 航空器进港排序

### 1.前言

* 到达飞机的调度可分为三个阶段:初始排序阶段、修改调度阶段和冻结阶段

### 2.研究方案

* 强化学习模型（武喜萍等，进港航班排序强化学习模型研究）
* 启发式算法模型
  * 遗传算法模型
  * 粒子群优化模型(PSO)（杨红雨等，人工鱼群—粒子群混合算法优化进港航班排序）
  * 蚁群算法模型（基于回溯的蚁群算法在航班进港排序中的应用）
  * 模拟退火模型（基于模拟退火算法的进港延误航班动态优化排序模型的研究）
* 基于数学模型
  * 基于改进自适应微分进化算法的进港航班排序
  * 进港航班排序优化数学模型研究
  * 基于 TCPN 网的并行调度模型（多跑道并行调度，基于TCPN网的双跑道航班进离港并行调度研究）
* 带约束条件的模型
  * 基于最小延误的进港航班公平排序（延误最小）
  * 基于最小延误成本的进港航班公平排序（成本最少）
  * FCFS（ETA时间排序）

### 3.其他领域

* 交通领域中的列车调度
* 工作流作业调度
* 资源调度问题
* ...

### 4.论文笔记

(1) 进港航班排序强化学习模型研究 (武喜萍等)

* 状态与动作空间

  * 状态   

    初始状态：航班ETA时间所在的排序序号；当前状态：航班当前的分配排序序号

    状态集：航班当前所在序列中可分配的所有排序序号。注意：可分配是指准点或往后延，但不可提前，因此当采取动作on_time时，排序序号为1，可选的排序序号再根据尾流间隔完成CTA时间的分配。
    $$
    S=\{index\ for\ index\ in\ range(current\_index,len(Eta_\_List)) \}
    $$

  * 动作

    在约束条件下，对航班到达时间进行调整，主要包括：准时、延误两类动作。延误操作通过遍历状态集中的所有状态，最后通过奖励函数筛选一个最佳的延误动作，并规定航班设定的延误不得晚于当前队列中末尾的航班。

    动作集：当前状态下所有的可行调整动作
    $$
    A=\{Action\ |\ on\ time \ or\ delay\}
    $$
    

*  奖励函数要求

  * 总延误时间最小
    $$
    min\sum_{f∈F}D_f(CTA_f-ETA_f)
    $$
    ​				其中D<sub>f</sub>表示是否延误，1表示延误，CTA<sub>f</sub>表示排序时间，ETA<sub>f</sub>表示预计到达时间；

  * 延误成本最小

    * $$
      min\sum_{f∈F}c_fD_f(CTA_f-ETA_f)
      $$

      ​															c<sub>f</sub>表示航班延误单位成本

  * 后续航班影响小
    $$
    min\sum_{f∈F}N_fc_fD_f(CTA_f-ETA_f)
    $$
    ​												N<sub>f</sub>若为1表示航班f有后续航班，否则没有后续航班

* 约束条件

  * 不允许提前降落，排序时间不得早于预计到达时间

  * $$
    CTA_f>ETA_f
    $$

    ​		当分配的CTA时间早于ETA时间时，将航班的CTA时间取为ETA；若有多架航班的ETA时间相同，则根据奖赏值来确定每架航班的CTA时间。

  * 进港航班流量不得超过机场的达到容量CAP
    $$
    \sum_{f∈F}f≤CAP
    $$
    
  * 尾流间隔标准（中国民用航空空中交通管理规则）：
    
    * 当前后进近着陆的航空器为**重型机**和**中型机**时，其非雷达间隔的尾流间隔时间不得少于**2**分钟；
    * 当前后进近着陆的航空器分别为**重型机**和**轻型机**、**中型机**和**轻型机**时，其非雷达间隔的尾流间隔时间不得少于**3**分钟；
    * 在**正侧风**风速大于**3米/秒**时，起飞和着陆航空器之间的尾流间隔时间不得少于**1分30秒**，但是仍应当遵守上述在起落航线上尾随飞行和交叉飞行的有关规定。

    ```python
    #定义尾流间隔时间标准，单位为分钟
    wake_interval ={'H':{'H':3,'M':3,'L':3},
                    'M':{'H':3,'M':3,'L':3},
                    'L':{'H':2,'M':2,'L':2}
                    }
    ```

* 奖励函数设计
  $$
  R=\alpha_1T+\alpha_2C+\alpha_3N
  $$
  ​		R为奖励函数，T为总延误时间，C为总延误成本，N为后续航班延误总成本，a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>分别为权重因子，和为1

* Q 值修正公式
  $$
  Q(s,a)\leftarrow Q(s,a)+\alpha[r(s,a)+\gamma maxQ(s',a')-Q(s,a)]
  $$
  s 为当前状态，a为状态s下可执行的动作，s'为后续状态，a'为状态s'下可执行的动作，r为奖赏

(2) 终端区飞机排序的模糊综合评判方法研究 (徐肖豪等)

* 主要思想：

  * 多进场航线各自内部排序(非最后排序)

    * 因素集：

    $$
    U=\{T_{NS},H,D_{TS}\} \\
    T_{NS}=[E_B-E_A]/R_S
    $$

    ​	 R<sub>s</sub> 代表A，B之间的最小间隔时间，T<sub>NS</sub>代表标准间隔时间，H为速度差，D<sub>TS</sub>表示先前排在后面的飞机离所在航段末端的距离。另外还需要一个输入量P,表示上一次的相对顺序，如：上一次A排在B前面，则P=1,上一次A排在B前面,P=-1,否则P=0,表示没有上一次的相对顺序。

    * 评价集：
      $$
      V=\{v_1,v_2\}
      $$
      ​									分别代表将A航班排在B航班前面，将B航班排在A航班前面

  * 汇合点处进行最后排序

    采用FCFS算法，第一架飞机的降落时间为该飞机的ETA时间，随后根据以下公式进行计算：
    $$
    S_i=max\{S_{i-1}+interval_{ij},E(i)\}
    $$
    S<sub>i</sub>表示第i架航班的安排降落时间， interval<sub>ij</sub>表示与第i架航班相邻的后续航班j的安全间隔时间(min),E<sub>i</sub>表示第i架航班的ETA时间。默认安排降落时间不早于ETA时间。

    
    
    
    
    ---
    
    Algorithm Q-Learning 
    
    ---
    
    ```python
    Require:
      States S = {19:00,19:00,19:05...,19:45}   # 总共有20架航班，排序序号状态为20种
    	Action A = {0,1,2,...,15}   # 表示采取延误的时间，0表示准点到，设置延误上限15为mins
      Reward Function R = R=a*T+b*C+c*N # a + b + c = 1
    	Learning Rate α = 0.01 # 设置学习率
      Discount Rate γ = 0.9  # 折扣率
      Procedure: # 主要算法部分
        episode = 1000 # 设置学习迭代次数，可以调整
        Initialize Q(state,action) = 0  # 初始化Q表为0
        Repeat (for each episode):
            Initialize State   # 初始化状态集，初始状态默认为序列中序号为1的航班所处的ETA时间
            Repeat (for each step of episode):
                Choose an action (delay or punctual) from State derived from Q # 贪婪或探索
                Take action   # 执行该动作(延误，准点)
                # 根据CTA时间将航班插入到初始序列中,并重新分配index，注意：此时的序列并不一定合法
                Insert flight into the initial sequence by time 
    
                # 尝试获得一个合法的CTA序列，调整CTA时间
                if flight index = 1:
                   CTA index sequence is euqal to ETA index sequence # 排列序号与ETA一致
                   Calculate the CTA refer to Wake interval # 根据尾流间隔补全时间
                   Check the CTA make sure ETA ≤ CTA # CTA不得早于ETA
                else：
                   Calculate the CTA refer to Wake interval 
                   Check the CTA make sure ETA ≤ CTA 
                   if the State Set has CTA : # 可分配的状态集合中有此CTA时间
                        set CTA to flight 		
                   else：
                        # 将航班往前移动一位，再作调整直到该CTA时间合法(符合尾流间隔)
                        Move the flight forward for one index till CTA is legal  
                        Calculate the CTA refer to Wake interval 
                        Check the CTA make sure ETA ≤ CTA 
                        
                 # Q-Learning算法核心部分
                 Calculate Reward R = a * T + b * C + c * N # 计算回报值
                 Q(s,a) <-- Q(s,a)+α[R+γmaxQ(s',a)-Q(s,a)]  # Q值更新
                 state s is changed to s' # 状态转换为具有最优Q值的状态(状态更新)
    			 untill state is terminal
    ```
    
    
    
    
    
    ### 排序算法分析
    
    1.最简单的方法就是遍历所有序列，找到一个最优的解。但是这样做的效率不高，而且有可能需要很长的时间来计算，比如有20架航班要进港，则总共的可能序列有20!=2.43290 x 10^18,搜索空间巨大，不可能在短时间内完成搜索任务。虽然可以通过控制进港航班数量来减少搜索空间，比如只有8架航班进港，那么搜索空间只有40320种，完成遍历还是可行的，但是进港航班的数量不是人为可控的，因此此种方案不适合。
    
    2.采用遗传算法来进行排序，方法可行，但是因为它有非常多的局部最小值点和局部最大值点，很容易使算法陷入局部最优，而不能得到全局最优解。
    
    
    
    
    
    
    
    
    
    
    
    
    
    