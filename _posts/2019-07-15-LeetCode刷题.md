---
layout: post
title: "LeetCode刷题记录"
date: 2019-07-10
description: "LeetCode刷题"
tag: LeetCode
---

182. 查找重复的电子邮箱
编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。（说明：所有电子邮箱都是小写字母。）
~~~
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
~~~
SELECT Email FROM Person 
GROUP BY Email
HAVING (COUNT(*) > 1)

3. 无重复字符的最长子串

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```
# 解法一：滑动窗口法  (运行时：68 ms，内存消耗：13.5 MB)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        usedchar={}  # 存放字符最后出现的下标
        start=res=0
        for index,char in enumerate(s):
            if char in usedchar and start<=usedchar[char]:
                start=usedchar[char]+1
            else:
                res=max(res,index-start+1)
            usedchar[char]=index
        print(usedchar)
        return res

s = "aacbacbac"
print(Solution().lengthOfLongestSubstring(s))  # output: 3

# 解法二：进栈法 (运行时：88 ms，内存消耗：13.2 MB)
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        #获取字符串s对应的列表
        s_to_list = list(s)
        stack = []
        max_length = 0
        for index in s_to_list:
            #如果stack栈中不包含index元素，则可以进栈
            if index not in stack:
                stack.append(index)
                max_length = max(max_length, len(stack))
            #如果stack栈中包含index元素，则要将前面index元素之前包括index元素的数出栈
            else:
                start = stack.index(index)
                stack[:] = stack[start+1:]
                stack.append(index)
        return max_length
        
s = "aacbacbac"
print(Solution().lengthOfLongestSubstring(s))  # output: 3
```