---
layout: post
title: "LeetCode刷题记录"
date: 2019-07-10
description: "LeetCode刷题"
tag: LeetCode
---

182. 查找重复的电子邮箱
编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。（说明：所有电子邮箱都是小写字母。）
~~~
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
~~~
SELECT Email FROM Person 
GROUP BY Email
HAVING (COUNT(*) > 1)

3. 无重复字符的最长子串

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```
# 解法一：滑动窗口法  (运行时：68 ms，内存消耗：13.5 MB)
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        usedchar={}  # 存放字符最后出现的下标
        start=res=0
        for index,char in enumerate(s):
            if char in usedchar and start<=usedchar[char]:
                start=usedchar[char]+1
            else:
                res=max(res,index-start+1)
            usedchar[char]=index
        return res

s = "aacbacbac"
print(Solution().lengthOfLongestSubstring(s))  # output: 3

# 解法二：进栈法 (运行时：88 ms，内存消耗：13.2 MB)
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        #获取字符串s对应的列表
        s_to_list = list(s)
        stack = []
        max_length = 0
        for index in s_to_list:
            #如果stack栈中不包含index元素，则可以进栈
            if index not in stack:
                stack.append(index)
                max_length = max(max_length, len(stack))
            #如果stack栈中包含index元素，则要将前面index元素之前包括index元素的数出栈
            else:
                start = stack.index(index)
                stack[:] = stack[start+1:]
                stack.append(index)
        return max_length
        
s = "aacbacbac"
print(Solution().lengthOfLongestSubstring(s))  # output: 3
```

7. 整数反转

   给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

~~~
class Solution:
    def reverse(self, x: int) -> int:
        s = str(x)[::-1].rstrip('-')  # 转字符串逆序，去符号(注意是右边)
        if int(s) < 2**31:            # 判断是否为32位有符号整数(范围为 [−2^31,  2^31 − 1])
            if x >=0:								  # 判断符号
                return int(s)         
            else:
                return 0-int(s)       # 此处用减法比较好，不要用乘法
        return  0
x = 12123
print(Solution().reverse(x))  # output: 32121
~~~

13.罗马数字转整数

思路：小的放在大的左边表示的整数为 大 - 小 ，小的放在大的右边表表示的整数为 大 + 小，所以遍历字符串，每次去取字符串前一位a和后一位b，令整数结果为res。if b <= a则 res += a的整数，else 则res += (b的整数 - a的整数)。

~~~
class Solution:
    def romanToInt(self, s: str) -> int:
        m = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        i,res = 0,0
        while i < len(s)-1:
            if m[s[i]] < m[s[i+1]]:          # 后一个比前一个数大，用减法
                res += m[s[i+1]] - m[s[i]]
                i += 2                       # 注意移动指针，向后移动2格
            else:
                res += m[s[i]]               # 未出现组合型，直接相加
                i += 1                      
        if i == len(s)-1:                    # 若最后单出一个，要单独处理末尾字符
            res += m[s[-1]]
        return res
x ="MCMXCIV"
print(Solution().romanToInt(x))  # output: 1994
~~~

14. 最长公共前缀

    ~~~
    class Solution:
        def longestCommonPrefix(self, strs):
            if strs == []:         # 字符串为空返回''
                return ''
            elif len(strs) == 1:   # 若列表仅有一个单词，返回该单词
                return strs[0]
            else:
                minlen = len(min(strs, key=len))  # 找到最短的单词长度
                s = ''
                for i in range(1, minlen + 1):    # 最多遍历 minlen 次
                    # 每次遍历同时从每个单词取相同长度的前缀加入集合，集合中不会有重复单词
                    # 列表中每个单词的相同长度前缀相同，因此集合长度为1
                    if len({s[:i] for s in strs}) == 1:
                        # 将s值更新为当前s长度与任意一个单词[:i]的部分中较大的那个值
                        # 为了避免不存在strs[1]，此处默认为第一个
                        s = max(s, strs[0][:i])
                return s
    
    strs = ["flower","flo","flkght"]
    print(Solution().longestCommonPrefix(strs))   #outpus fl
    ~~~

20. 有效的括号（括号匹配）

    ~~~
    class Solution:
        def isValid(self, s: str) -> bool:
            one = ['(', '[', '{']
            two = [')', ']', '}']
            mapping = dict(zip(one, two))
            stack = []
            for i in s:
                if len(stack) == 0 or i in one:   # 栈为空或字符为左括号则进栈
                    stack.append(i)
                elif (stack[-1] in one) and (mapping[stack[-1]] == i):
                    # 若栈中最后一个字符为左括号并且i为与之对应的右括号
                    stack.pop()     # 将栈中上面的元素出栈
                else:
                    return False
            if len(stack) == 0:     # 若遍历结束后栈为空说明全部匹配成功
                return True
            else:
                return False        # 否则有未匹配的括号，返回False
    
    print(Solution().isValid("{[]}"))   # outputs  True
    ~~~

    

